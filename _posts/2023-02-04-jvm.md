---
title: "[Java] JVM에 대해"
date: '2023-02-05 +0900'
description: '기술면접 정리하기 - jvm'
categories: [Study,Java]
tags: [Java,기술면접]
---

> 2월 1주차 스터디 발표 자료📖                                    
> 기술 면접을 준비하며 정했던 주제 중 7번 째 주제입니다!           
> JVM(Java Virtual Machine)에 대해 정리하고자 합니다.

## **JVM의 정의** ##
---
* Java로 개발된 프로그램을 컴파일하면 만들어지는 **자바 바이트코드**를 각 OS에 특화된 코드로 변환하여 실행시켜주는 **가상머신**이다.        
➔ 즉, **OS에 종속받지 않고 CPU가 Java를 인식하여 실행 할 수 있게 해주는 가상 컴퓨터**이다.
* ***Garbage Collection***을 통해 메모리 관리를 수행한다.

## **JVM의 실행과정**
---
1. Class Loader를 통해 .class 파일들을 **JVM 메모리에 탑재한다.**
2. **JVM 메모리에 탑재된 클래스 파일(바이트 코드)들은 실행엔진의 Interpreter와 JIT Compiler를 통해 기계어로 번역되어 명령어 단위로 실행**된다.

## **JVM의 구조**
---
![jvm의 구조](/assets/img/jvm%EA%B5%AC%EC%A1%B0.jpg){:style="border:0.2px solid ;border-radius: 6px; padding: 0px; " }  
### 1. **클래스 로더?** ###
- .class 확장자를 가진(컴파일 된 클래스) **클래스 파일을 찾아서 JVM의 메모리에 탑재해주는 역할**을 한다.
- ***모든 클래스 파일을 한번에 메모리에 올리는 것이 아닌***, **요청이 있을 때마다** 파일로부터 읽어서 메모리에 탑재한다.  
- **클래스 로더가 클래스 로드 요청을 받으면? (위임 구조)**
    1. **캐시 확인:** 이전에 불러온 클래스인지 확인
    2. **상위 클래스 로더 확인:** 상위 클래스 로더에서 불러온적 있는지 확인
    3. **자기 자신 확인:** 하위 클래스 로더(본인)에서 불러온다.       
    <br>
- **클래스 로더 시스템의 동작 과정?**
![클래스 로더 동작과정](/assets/img/classloader.jpg){:style="border:0.2px solid ;border-radius: 6px; padding: 0px; " }     
    1. **Loading?**    
    **.class 파일을 읽고 그 내용에 따라 적절한 바이너리 데이터를 만들어, Method 영역에 저장**한다. **로딩이 끝나면** 해당 클래스 타입의 객체를 생성하여 ***힙 영역에 저장한다.***   
    **➔ 즉, 간단히 말하면 클래스 파일을 JVM의 메모리 영역에 로딩한다.**       
    <br>     
    2. **Linking?**     
        **2-1. 검증단계**       
        바이트 코드가 **정상적으로 자바의 규칙을 따르고 있는지 검증한다.**       
        **2-2. 준비단계**      
        클래스가 필요로하는 **메모리양을 미리 할당해둔다.**     
        **2-3. 분석단계**             
        해당 클래스가 **참조하는 객체의 실제 메모리 주소 값을 할당한다.**         
        <br>
    3. **Initialization?**    
    클래스 안의 **static 변수의 값을 할당하고 클래스를 초기화한다.**

- **클래스 로더의 종류 (계층적 구조)**
    1. **Bootstrap Class Loader?**    
    JVM을 실행할 때 **가장 먼저 실행**이되며, 자바의 **기본적인 클래스를 로드**한다.   
    2. **Extension Class Loader?**    
    자바의 **기본 클래스에서 확장된 클래스**를 로드한다.
    3. **System Class Loader?**    
    **classpath안에 있는 클래스들을 로드**한다.(개발자가 작성한 소스파일)
    4. **User-Defined Class Loader?**    
    **사용자가 직접 생성**해서 사용하는 클래스 로더

### 2. **실행 엔진?** ###
- **Class Loader로 Load된 클래스 파일(바이트 코드)** 을 실행한다.
- CPU는 바이트 코드를 이해하지 못하기 때문에, **기계어로 번역하는 과정이 필요하다.**

- **실행 엔진의 실행 방식?**
    1. **Interpreter?**     
    바이트 코드를 **한줄씩 읽어** 기계어로 변환하여 실행한다.
        - **단점?**      
        **반복 호출되는 메서드를 매번 기계어로 번역해야하므로, 비효율적이다.**         
    2. **JIT Compiler**     
        - 인터프리터의 문제를 해결하기 위한 컴파일러
        - **코드 전체에서 반복 호출되는 메소드가 있다면, JIT Compiler가 기계어로 변환하여**       
        **Native Method Stack에 저장한다.**      
        - 변환된 부분은 **인터프리터에 의해 실행되지않고 기계어 상태(native code)로 즉시 실행된다.**     
        - **JIT 컴파일러가 컴파일 하는 과정은 인터프리팅 방식보다 훨씬 오래걸리기 때문에,**      
        한 번만 실행되는 코드라면 인터프리팅 하는 것이 유리하다.    
        - 따라서 JIT 컴파일러를 사용하는 JVM들은 **내부적으로 해당 메서드가 얼마나 자주 수행되는지**    
        **확인하고 일정 수준 이상으로 사용된다면 컴파일을 수행하게 된다.**

### 3. **가비지 컬렉션?** ###
**동적으로 할당한 메모리 영역** 중 **사용하지 않는 영역을 탐지**하여 **해제**하는 기능     
➔ 해당 내용은 포스팅으로 따로 정리해두었다!

### 4. **런타임 데이터 영역?** ###
- **PC register, Stack, Native Method Stack**은 ***스레드마다 하나씩 생성***된다.
- **Heap, Method** 영역은 ***모든 스레드가 공유해서 사용***한다.
    1. **PC register?**
        - JVM이 **수행 중인 명령어의 주소**
        - 각 스레드가 **시작될 때** 생성된다.
        - **만약, 네이티브 메서드를 실행하고 있다면 PC register 값은 정의되지않는다.**
    2. **Stack?**
    - 각 스레드가 **시작될 때** 생성된다.
    - **Frame**을 저장하는 스택
    - 메서드가 수행될 때마다 **하나의 스택 프레임이 생성되어 해당 스레드의 Stack에 추가되고**,      
    **메서드가 종료되면 스택 프레임이 제거**된다.       
    - **🤔Frame은 뭘까?**    
    메소드 **상태 정보**를 저장하는 영역      
            1. ***Local Variable***   
            **메소드 안의 지역 변수들을 array 형태로 가지고 있다.**
            2. ***Operand Stack***   
            **메소드 내 연산**을 위해, **바이트 코드 명령문들이 들어있다.**
            3. ***Constant Pool Reference***    
            **Constant Pool 참조를 위한 공간**
    3. **Native Method Stack?**
    - 자바 외의 언어로 작성된 **Native Language**를 위한 스택
    4. **Heap?**
    - **모든 스레드들이 공유하는 메모리 영역**
    - new 키워드로 생성된 **객체와 배열이 저장**된다.
    - ***Method Area에 로드된 클래스만 생성이 가능하다.***
    - 참조하는 변수나 필드가 없다면 **접근할 수 없는 객체가 되어 GC의 대상이 된다.**
    - **Heap** 영역이 가득 차게 되면 **OutOfMemoryError**를 발생시키게된다.
    5. **Method Area?**
    - **모든 스레드들이 공유하는 메모리 영역**
    - **클래스가 Loading될 때 생성**
    - **클래스 정보, 변수 정보, 매소드 정보, Static 변수, final class 변수, Constant pool 등을 분류해서**      
    **저장한다.**        
    - **🤔 Constant Pool?**    
    ***문자 상수, 타입, 필드, 객체 참조가 저장되는 영역***
